<!-- HTML header for doxygen 1.8.6-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="shortcut icon" type="image/x-icon" href="odlogo_small.ico" />
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
    <meta name="keywords" content="object detection, object recognition, detection, recognition, vision, computer vision, image processing, point cloud, opens ource"/>
    <meta name="description" content="Open Detection, OD, is a standalone open source project for object detection and recognition in images and 3D point clouds."/>
    <meta name="author" content="Kripasindhu Sarkar"/>
<title>Open Detection: /home/giacomo/libraries/opendetection/doc/doxygen/tutorials_doxygen/gsoc2016_blog_giacomo.md Source File</title>
    <link rel="stylesheet" href="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
    <script src="http://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"></script>
    <style>
        .carousel-inner > .item > img,
        .carousel-inner > .item > a > img {
            width: 70%;
            margin: auto;
        }
    </style>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() {
    if ($('.searchresults').length > 0) { searchBox.DOMSearchField().focus(); }
  });
</script>
<link rel="search" href="search_opensearch.php?v=opensearch.xml" type="application/opensearchdescription+xml" title="Open Detection"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Open Detection
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>OD</span></a></li>
      <li><a href="tutorial_root.html"><span>User&#160;Guide</span></a></li>
      <li class="current"><a href="usergroup0.html"><span>API&#160;Documentation</span></a></li>
      <li><a href="usergroup1.html"><span>GSoC16&#160;Blogs</span></a></li>
      <li><a href="idea_list_gsoc2016.html"><span>GSoC&#160;2016&#160;Ideas</span></a></li>
      <li><a href="installation_instruction.html"><span>Downloads</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
          <div class="left">
            <form id="FSearchBox" action="search.php" method="get">
              <img id="MSearchSelect" src="search/mag.png" alt=""/>
              <input type="text" id="MSearchField" name="query" value="Search" size="20" accesskey="S" 
                     onfocus="searchBox.OnSearchFieldFocus(true)" 
                     onblur="searchBox.OnSearchFieldFocus(false)"/>
            </form>
          </div><div class="right"></div>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('gsoc2016__blog__giacomo_8md.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">/home/giacomo/libraries/opendetection/doc/doxygen/tutorials_doxygen/gsoc2016_blog_giacomo.md</div>  </div>
</div><!--header-->
<div class="contents">
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;GSoC 2016 Blog - Giacomo {#gsoc2016_blog_giacomo}</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;====</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[TOC]</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;#Framework design and library maintenance#  {#gsoc2016_blog_giacomo1}</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;====</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;  - [Link to Proposal](https://docs.google.com/document/d/16Wyd0h5b9-7DaG7ZYJT30a2i096krviFUCcDYwg-jZc/edit?usp=sharing) - [Link to GSoC2016 Project Page](https://summerofcode.withgoogle.com/organizations/6007728078061568/#5675882488266752)</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;  - [Link to commit list](https://github.com/giacomodabisias/opendetection/commits/master)</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160; </div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;##About Me##</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;I finished my **joint master degree** in computer science and networking at Sant&#39;Annas school of advanced studies and the university of Pisa in 2014 with a thesis on the static allocation of real-time OpenMP jobs on multicore machines. The master program was focused on parallel and high performance computing including OpenMP, MPI, Cuda and Tbb.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;I started then working as a scholar on the Pelars project (Practice-based Experiential Learning Analytics Research And Support) at the Laboratory of Perceptual Robotics (PERCRO), which is part of the Institute of Communication, Information and Perception Technologies (TECIP) of the Scuola </div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;Superiore Santâ€™Anna, Pisa.</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;In November 2014 I started my PhD in Perceptual Robotics, researching Computer Vision for robotic applications. The first part of my research concerned object recognition algorithms, mainly developing real time solutions; I have worked with different approaches ranging from classical descriptor matching pipelines to machine learning techniques. Both 2D and 3D approaches have been investigated, using different platforms and sensors. I am also active in the research area of RGB-D cameras creating interfaces and testing new sensors.</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;I stayed as a visiting student for one month at **ETHZ** to investigating object recognition using **Random Forests**, which gave me some great insights on the use of machine learning tecniques in this filed. </div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;Code is mainly developed using **C**++, **Java**.</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;I am contributing to the different libraries like **PCL**, **OpenCV** and **libfreenect2**.</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;-[Link to Github](https://github.com/giacomodabisias)</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;##General Project Idea##</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;The concept of this gsoc project is to restructure the OpenDetection Library in order to make it more usable, scalable and documented. In a second phase there could also be the possibility to implement some new features in the library.</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;The implementation can be divided into several work tasks</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;- **Task 1** - fix dependencies and modular build : Restructure the Cmake files to obtain a clean and expandable structure. Remove as many dependencies as possible and set build options for the different OpenDetection modules based on the OpenCV/PCL dependencies. </div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;Depending on OpenCV/PCL version activate/deactivate modules of the library.</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;- **Task 2** - small tasks : Restructure the code by moving the different files into appropriate folders. Move 3rd party software to git sub modules or downloadable cmake content. Use more templetization and create precompiled versions for basic types. Enhance performances by optimizing the whole code structure. All these steps include the addition of a fixed coding style which can be derived or adopted by an existing one. </div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;- **Task 3** - moderate task - memory allocation : Restructure memory allocation using shared_pointers where possible to avoid dynamic memory allocation with new. </div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;- **Task 4** - moderate task - generalized viewer : Create a generalized viewer interface for 2D images and 3D point clouds based on VTK. </div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;- **Task 5** - moderate task - packaging and cross compilation : Fix the Cmake files in order to make the library cross platform buildable on Linux and Windows systems. Add header precompilation if possible and ProjectConfig.cmake files to to make the library usable by other projects. </div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;- **Task 6** - moderate - input enhancements : A lot of classes have the possibility to load data from file/path. Create template versions of them in order to let people also load data from vectors/arrays etc.. </div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;- **Task 8** - small - Documentation and examples : Continue the documentation process and add new examples for the new implemented structures/algorithms. </div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;- **Task 9** - small task - merge other gsoc16 contributions : Merge changes from other contribution of GSOC. Other projects will be using existing APIs. There might me need to make small changes to fit to the changes made in this project </div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;- **Task 10** -  moderate task - deb packaging : Create an automated way to generate a deb file for the library so it can be installed through debian packaging system.</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;##Fix 3rd party dependencies 12/05/16##</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;The library has some dependencies inserted as source code into the 3rdparty folder; these are pugixml and SiftGPU (and maybe others which will come later). There is also the dependency of svmlight, but this is not mandatory so it will be added as external dependency; if the library is present on the system all the depending libraries will be built.</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;In general its a bad idea to integrate external source code into a library since you can&#39;t have update versions which maybe fix bugs etc.. and you have to take care of licenses. To fix this issue I removed the two folders (**pugixml** and **SiftGPU**) and added the git repositories of these two libraries as submodules. This way, when a user is downloading the opendetection library, he will also download the lates version of the two libraries. One could argue that the API of the libraries could change, but it is possible to checkout a fixed version in order to avoid these issues.</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;- **SiftGPU** can just be added with the **add_subdirectory** cmake command which will execute the *CMakeLists.txt* in the library folder and export the produced targets (libsiftGPU.so in this case.</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;- **Pugixml** is a bit more tricky since it has no cmake file; it contains a Make file which produces a test executable but no library. The library can be easily built since we have just two include files and one .cpp file. To fix the issue I created a separate pugixml_build folder with a simple custom cmake which builds the library. This way we can just add that folder as add_subdirectory and directly export the newly compile **libpugixml.so** library.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;- **Svmlight** will be inserted in the system with a find_package or something similar and a custom **WITH_SVMLIGHT** cmake flag. These steps will come shortly; we will just leave the svmlight binding.</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;##Refactoring file structure 13/05/16##</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;I started to move files in appropriate folders and to fix the &quot;Main&quot; *CmakeLists.txt* file. I renamed the ODconfig.h.in file to od_config.h and moved it into the cmake folder for now. Then I moved the opendetection.cpp source file away from the root (not nice to have source files in the root of a library) and added it as separate app in a new version folder which builds the od_version executable.</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;I fixed the **OD_ADD_EXAMPLE** macro adding the **INCLUDE** argument to include specific headers and used it in the *od_version* app. A separate cmake file has benn created to include all MACROS, but I have still to check if it is possible to add ordering between include cmake statements since there are some dependencies between the files. I separated the **OD_CMAKE_DIR** from **CMAKE_MODULE_PATH** in order to have a clear struture and to not mix up folders; the files in the cmake folder have also been renamed to have a common naming scheme.The next step will involve separating source and header files in appropriate folders and adding them in the cmake without explicitly naming them to avoid problems when renaming files in the library.</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;The next huge step consisted in refactoring common, detectors and example folders to have a common standard file structure. This is usually built having in each folder the following subflders/files:</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;- CMakeLists.txt : the usual cmake build file</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;- src : all the source files which can be subdivided into folders</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;- include : a folder hierarchy which resambles the src structure. This is very useful to install include files and to maintain clear include names</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;- impl : a floder containing the template files (.hpp usually).</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;This resembles also the structure used in the PCL library.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;After refactoring the folders, all the involved CMakeFiles had to be restructured to adapt to the new structure. The first version still uses all file names explicitly, but it should be possible to automate the file detection process by using the cmake command *file(GLOB VAR PATTERN)* which finds all file in a gve folder which match a given pattern. This can be done also in a recursive manner. I will probably use this for some folders to be independent (partially) of file names, locations and number.</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;##Making examples optional 17/05/15##</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;Examples should not be built always, or at least it should be possible to not build them at all or partially. To do so I added the **WITH_EXAMPLES** option whichi enables the building of the examples. Then for each example I added a variable to trigger the building process of that examples:</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;@code</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;option(image_hog_files_example &quot;Build the hog image example&quot; ON)</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;if(image_hog_files_example)</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;        OD_ADD_EXAMPLE(od_image_hog_files FILES od_image_hog_files.cpp</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;                        LINK_WITH od_common od_global_image_detector)</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;endif()</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;@endcode</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;The option command adds an option in the cmake; the first parameter is the cmake option name (which for now is written in that way but it will probably change), the second is a description of the option, and the third is the default option value. I left it on on so that even unexperienced user can build some examples to test the library. The option is then followed by an if which checks the option vale and in case adds the example to the build process. I would like to change also the structure of the example folder by creating subfolders which then contain the different examples subdividing them by **type** . Each folder will then have its own *CMakeLists.txt* file which can be added by the parent cmake with the usual *add_subdirectory* command. This helps also since we can add automatically all the subfolders of the example folder to the build process without stating the names explicitly.</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;##Include structure 18/05/15 ##</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;While continuing to restructure the library I came across a decision which can be solved in different ways but for which I still don&#39;t have the best solution. Lets assume we want to include a global 3D detector for example, we would use *ODCADDetector3DGlobal.h* . We could have in our file </div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;@code</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;#include &lt;ODCADDetector3DGlobal.h&gt; </div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;@endcode</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;and the compiler would need the include folder where the file is located to compile. This means that the file should be localted directly in the upper include folder, but this is not our case since the structure is like *detectors/global3D/detection/* so it would be better to have</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;@code</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;#include &lt;detectors/global3D/detection/ODCADDetector3DGlobal.h&gt; </div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;@endcode</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;and include the upper level folder. To use the first solution we would need to include *detectors/global3D/detection/* but this is not really appealing since it would mess with the whole include structure. For now I opted for the second solution, but the include structure could be changed at any time. This way the include file structure resables exactly the source file structure:</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;- common</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160; * bindings</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160; * pipeline</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160; * utils</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;- detectors</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160; * global2D</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;   - detection</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;   - training</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160; * global3D</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;   - detection</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   - training</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160; * local2D</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;   - detection</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;   - training</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160; * misc</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;   - detection</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;The new structure compiles fines except for three examples which have a linker bug (undefined reference to `vtable for od::g3d::ODCADDetectTrainer3DGlobal&#39;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;) which I am trying to resolve. I fixed a bit the source code of all the examples removing unnecessary includes, fixing namespaces, maintaining a common interface and avoiding dynamic memory allocation where possible. The next step after fixing the linker bug will be to fix the install paths for includes and libs. </div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;##Include structure and install target 23/05/16##</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;I fixed the linking error; it came from a wrong variable name in a cmake file which specified some source files which were not compiled and so the linking error. I split simple_ransac_detection in src and include and reinserted it in local2D detectors since it is used only there. The source files are just added to the local2D library and compiled together.</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;Next I moved to fix the install target in the cmake. In our case, since we have already a clean structure of the include folders which we want to maintain we can directly copy the include folders of each module (detectors and common) into the include folder specified by *CMAKE_INSTALL_PREFIX* . We just need to create an upper folder called od-$VERSION to avoid conflicts with different library versions on the same machine. The clean include structure allows also to remove the explicit single include files from the install targets and allows to use directly the cmake command</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;@code</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;install(DIRECTORY ${DETECTORS_INCLUDE_DIR}/od DESTINATION ${OD_INSTALL_INCLUDE_DIR})</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;@endcode</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;with the DIRECTORY keyword to copy the whole folder. Also I removed the include files from the </div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;@code</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;OD_ADD_LIBRARY_ALL(&quot;${SUBSYS_NAME}&quot; SRCS ${SOURCES})</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;@endcode</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;since you don&#39;t have to compile headers files.It is enough to specify the include folders to find the includes at compile time. It could be possible to add header precompilation, but I believe this would be an advanced step which could be implemented at the end. I still need to check if this way of installing includes using the *DIRECTORY* keyword without specifying the single files is the clearest way.</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;##Code refactoring 01/06/15##</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;Before modifying and digging into the code I wanted to have a common coding style in all files, fixing also some common coding mistakes when found. Another decision was to use C++11 features whenever possible since it should be considered a basic standard, having already C++17 code online. I started by fixing the &quot;common module&quot;; here I did the following:</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;- I removed the ToString method since in c++11 it is present as *to_string()*; </div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;- I removed global variables from utils since they where just used in one function.</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;- I removed the *FileUtils* class which was a class with only static functions. This is equivalent to the new structure which is a namespace with defined functions which is more readable and less prone to errors.</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;- I removed the time.h headers everywhere in order to use chrono from the std library.</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;- I added constness modifiers and references for passed arguments whereever possible to avoid useless parameter copyes.</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;- I modified the frame generator template to have as parameter generic clouds and not only pointrgba point clouds</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;After this I started to fix the detectors which I am still working on. The first class which has bee updated is the *ODHOGDetector* which had also a lot of naming issues since it used a different naming style. </div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;There are stll some function which I dislike, for example the parsing methods. They are mainly based on creating a fake argc,argv couple of variables and the parsing them. This has to be removed in favor of a better and newer parsing library as the one included in boost. This will be one of the first steps which I will do as soon as I finished the basic refactoring step.</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;##Code refactoring 2 07/06/16##</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;The first code refactoring phase terminated today, since I finished to review a bit all files; the main steps have been:</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;- moving around code in order to have implementations in the cpp files to reduce multiple compilation time, and declarations in .h files. </div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;- added some minor c++11 features like *ranged-loops* instead of iterators which are hard to read, more standard function like *to_string()* and *itos()* where possible</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;- removed standard namespace and opencv namespace to avoid name clashing</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;- refactored the whole simple ransac file folder which was outside of the namespace</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;- used a common coding style through all files which is fundamental</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;- I moved the **ODDetectorMultiAlgo.h** and **ODDetectorMultiAlgo.cpp** files into ODDetectorMultiAlgo.hpp since I made the classes template to avoid having the explicit **Pcl::PointXYZRGBA** type since it was using ODCADDetector3DGlobal.hpp which already defined template classes. The new file is situated in the impl folder in detectors to maintain the usual include structure. Now, since the default vale has been removed for the template classes, the type has to be specified when the class is instantiated which can been seen in the examples.</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;Missing parts and next steps:</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;- I have to check that compilation works fine also with svmlight which was disabled till now</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;- Use shared pointer where normal pointer are used. We have to decide if we want to use boost or stds shared pointers since pcl is using the first version. The second would be better so we would have everything which is possible using std and then when pcl moves toward std shared pointer we move also the rest of the code to that.</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;- Remove where possible the argc,argv parsing methods using standard ones.</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;##Shared Pointers 10/06/16##</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;The following step took quite a bit in order to have everything work well. Until now the library was using normal C++ pointer created with new and then deleted when not used anymore. This can lead to bad habits of forgetting to delete pointers, causing memory leaks. To avoid this its always good to use safe pointers which get deallocated as soon as they are not referenced my anyone anymore. Safe pointers are called **shared_ptr** in C++ and were intially implemented in the *Boost* library; then, after C++11, they where also inserted in the standard in the *std::* namespace. Substituting all pointers n the library was quite a complex task for different reasons:</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;- Opendetection uses quite a lot the *Pcl* library. This library is still using the **boost::shared_ptr** implementation instead of the **std::shared_ptr** implementation. The two **shared_ptr** are not compatible and so a big issue arises. Should we use the first or second implementation? We should use the second solution since it relies on the standard, but we can&#39;t since *Pcl* still uses the first implementation. While *Pcl* moves to the *std::* solution we need to use the *boost* namespace, so in order to have the library compatible with both implementations, beeing able to switch from one to the other, I added a simple header file which switches between the two shared pointer types. This way as soon as *Pcl* moves to the *std::* we can also switch by just setting a variable in the cmake. The variable is called **WITH_BOOST_SHARED_PTR** ad is set to on by default so that we use *boost::shared_ptr* for now. </div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;- Substituting a pointer with a shared pointer requirest also to use another set of functions for the creation and the casting. to create a **shared_ptr** you either pass the pointer to the constructor or use the **make_shared** template passing to the function the constructor arguments and as template argument the pointer type. Also static and dynamic casting have specific template functions which are **dynamic_pointer_cast** and **static_pointer_casto**.</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;- It is important to remove all delete which are around the code since **shared_ptr** automatically destroy the pointed objects in the destructor if not referenced anymore.</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;While restructuring the code I also fixed again some coding style issues, but I still have to go through the code a few more times in order to finish fixing everything. The next step is as previously mentioned, to check the compilation with the svmlight option.</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;##Cmake improvments 20/06/16##</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;I created a **FindOD.cmake** which can be used by other libraries to find the include directories path, the library path and the library names. The variables which get set are:</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;- OD_INCLUDE_DIRS </div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;- OD_LIBRARY_PATH </div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;- OD_LIBRARIES </div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;There variables can be used in any project by using:</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;@code</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;find_package(OD REQUIRED)</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;include_directories(${OD_INCLUDE_DIRS})</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;link_directories(${OD_LIBRARY_PATH})</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;target_link_libraries(example_target ${OD_LIBRARIES})</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;@endcode</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;The **FindOD.cmake** is generated automatically starting from the **${CMAKE_INSTALL_PREFIX}** variable so there is no absolute path and it is installed in **${CMAKE_INSTALL_PREFIX}/lib/cmake/** .</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;I added then an **uninstall** target to delete all the installed files if necessary. This custom target is standard and can be found easily on the internet.</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;Another important missing thing was the creation of a .deb package which can be useful to install the library on other systems. This package has been created using the **Cpack** utility provided by cmake. By just setting some basic variables it is possible to create e complete .deb file which can then be installed using the usual *dpkg -i package.deb* command.</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;All files in the library have been renamed according to a common scheme which consists in a Prefix &quot;OD&quot; followed by the first charachter of the file name uppercase.</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;##Templates and Windows compilation 27/06/16##</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;To improve compilation time of projects using the **OpenDetection** library I decided to precompile all the templates for the most common types. In this case almost all templates depend on *pcl* point types. The most commonly used point type for which I precompiled the library are:</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;- *pcl::PointXYZ*</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;- *pcl::PointXYZRGB*</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;- *pcl::PointXYZRGBA*</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;It is important to create for each .hpp header file containing the templates a .cpp file in which templates are instantiated with the different types. Explicit template instantiation is done by just writing *template* followed by the template declaration with the instantiated type.</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;The most important part is to insert in the header file the same declaration with the *extern* keyword at the beginning. This informs the compiler that the defined symbol is already present in another compilation unit and that it can be found at linking time. Without this the compiler will just reinstantiate the templates and recompile them since it has no knowledge about templates instantiated and compiled in other compilation units.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;I then fixed all the linking in the whole library since there where some useless linked libraries in order to speed up even more the compilation. </div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;After that I tested compilation of the library under Windows, but without success. There have been several issues which are ut of the Open Deteciton library. I tested compilation using **Visual Studio 2015** and **MinGW**. Pcl has been installed by using the prebuilt version while opencv has to be built manually since *opencv_contrib* is necessary while not present in the prebuilt binaries. Building opencv3 with visual studio and cuda is not possible at the moment since cuda 7.5 is not compatible with visual studio 2015, so version 8 is necessary which will be available soon. MinGW is also not usable since compilation of opencv3 with cuda is disabled as flagged as incompatible by opencv.</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;##Face detection 31/06/16##</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;To test the new cmake and code structure I **implemented face detection** (not recognition which is already available). Face detection is implemented in *OpenCV* both in **CPU** mode and in **GPU** mode (using **CUDA**). </div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;I created an interface which is using the *ODDetector2D* interface to use both **CPU** and **GPU** mode based on a parameter passed in the constructor. **GPU** mode is only available if the library was built with **GPU** support (using the *WITH_GPU* flag in the cmake file). </div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;To test the new detector I created two examples; the first one is *od_face_detecor_cam.cpp* which uses the first found webcam to detect faces; the second example is called *od_face_detector_files.cpp* which uses a path to a file folder to execute the face detection algorithm over all files present in that folder. </div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;I noticed that it is necessary to pass to the *ODFrameGenerator* a file expression like /home/test/images/\*.jpg. I don&#39;t really like this method since it is quite restrictive and not intuitive to call. I will add also a function using **boost filesystem** to iterate over all files which are OpenCV supported images, using as input a path name.</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;I added in the cmake the two new examples with a custom option and tested them successfully.</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;The next step will be to add the functionality previously described to the frame generator; I will also add the possibility to use standard containers as input sources in roder to be able to use arrays, vectors and lists for example.</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;##Face detection 2 06/07/16##</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;After talking with Kripa I found out that the CPU cascade detector (the detector used to detect faces) was already rpesent n the library; so only the gpu version had to be added. This implies to create in the library a new gpu folder containing all gpu modules which should be built only if support is present.</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;To do this I created a separate gpu folder which contains for now a detector folder with the same structure as the external one. Everything defined here should be in the **od::gpu::** namespace and each class should have the same name as the cpu version class. It is also a good habit to first create a common interface for the **CPU** and **GPU** version in order to be able to dinamically allocate objects of both types.</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;To grasp better the meaning I implemented the **cascade detector** as follows:</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;Both detectors derive already from the same class so there is no need for an additional interface</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;@code</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;class ODCascadeDetector : public ODDetector2D</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;@endcode</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;Each class has a different detector member:</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;GPU</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;@code</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;cv::Ptr&lt;cv::cuda::CascadeClassifier&gt; haar_cascade_;</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;@endcode</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;CPU</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;@code</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;shared_ptr&lt;cv::CascadeClassifier&gt; haar_cascade_;</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;@endcode</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;This way we can do the following when using the detectors:</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;@code</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160; boost::shared_ptr&lt;od::ODDetector2D&gt; detector;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160; if(gpu)</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160; {</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;   detector = boost::make_shared&lt;od::gpu::g2d::ODCascadeDetector&gt;(argv[1]);</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160; }else{</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;   detector = boost::make_shared&lt;od::g2d::ODCascadeDetector&gt;(argv[1]);</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160; }</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;@endcode</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;There were three possible solutions to how to impement gpu in the library:</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;- Add in the constructor a flag to decide the **CPU** / **GPU** mode. This mixes up gpu and cpu code in the same class and changing anything becomes more and more difficult</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;</div><div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;- Create two separate classes with dfferent names,  one for each type. This fixes the previous issue but moving from one version to the other can be hard</div><div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;</div><div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;- Create a common interface and have the same class imlemented in different namespaces. Clean solution which has been adopted.</div><div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;</div><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;I removed the previous facedetector classes which I had added and used the new ones in the examples which I had previoulsy created. I also used the new viewer in all examples and fixed the build of the different examples to be independent and clean in the *CMake*.</div><div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;</div><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;##Visualizer update 11/07/16##</div><div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;</div><div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;To cover all examples and to have a more versatile viewer I added today an interface so add and remove text, clouds and added some improvments to be able to have multiple clouds in the same viewer at the same time. There is still some testing needed. I also added as usual all the template precompilation for the common PCL types.</div><div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;</div><div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;The next step consists in adding as stated before the std::containers to the frame generator class and then have a look if there are some modules to move to the gpu folder or maybe add some new methods there.</div><div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;</div><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;##Modular build 15/07/16## </div><div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div><div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;Looking at the *PCL* and *OpenCV* libraries I noticed how the libraries are subdivided into modules. I understood then the importance of having this structure also in the OD library and so started to change a bit the structure, expecially the *Cmake* structure, to support such a feature. </div><div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;With the new changes now each detector is a separate module which can be built or not as also gpu. One issue was that some modules might have dependencies on other modules and can be built only if a specific module was built. For example the misc detector can be only built if other detectors where built. </div><div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;To overcome this issue I found that you can specify targets in **IF** statments in *CMake*. This allowas to check if a specific module was built and in case continue with the build process. It the specific module was not built, an error message is displayed explaining which module is missing. The if statment needs the **TARGET** statment in fron of the moduel in order to search in the built targets. An example is the following:</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;</div><div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;@code</div><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div><div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;if(BUILD_MISC_DETECTION)</div><div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;    if(TARGET od_global_image_detector AND TARGET od_pointcloud_global_detector)</div><div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;     set(SOURCES</div><div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;         &quot;detection/ODDetectorMultiAlgo.cpp&quot;</div><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;         )</div><div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;     include_directories(${DETECTORS_IMPL_DIR})</div><div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;     include_directories(${DETECTORS_INCLUDE_DIR})</div><div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;     include_directories(${COMMON_INCLUDE_DIR})</div><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;     include_directories(${CMAKE_3RDPARTY_DIR}/svmlightlib/)</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;     include_directories(${PCL_INCLUDE_DIRS})</div><div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div><div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;     OD_ADD_LIBRARY(&quot;${SUBSYS_NAME}&quot; SRCS ${SOURCES} LINK_WITH ${SUBSYS_DEPS})</div><div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;</div><div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160; else()</div><div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;   message(&quot;!!! BUILD_MISC_DETECTION is set to on but BUILD_GLOBAL_2D_DETECTION and BUILD_GLOBAL_3D_DETECTION is necessary to build BUILD_MISC_DETECTION&quot;)</div><div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160; endif(TARGET od_global_image_detector AND TARGET od_pointcloud_global_detector)</div><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;</div><div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;@endcode</div><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;</div><div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;As you can see we need to have the global_image_detector and the pointcloud_global_detector in order to build the misc module, along with the option to build the misc module. If the **IF** statment fails an error message is displayed asking to build those missing modules.</div><div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;The same structure has been adde to all examples so that the correct examples are automatically built depending on the built modules. it is important to notice the repeated **include_directories** for each example. Its true that one is enough for all the built targets in that file, but with this modular built its not possible to know in advance which examples will be built. Also it is not nice to include everything at the beginning since this will only slow down compilation and make the code less readable since it covers up dependencies of example-&gt;includes.</div><div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;</div><div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;I also built the system on lniux 16.04 with gcc 5.3; I had some initial issues but also those were fixed. I will make a blogpost about them next week since some errors where quite interesting.</div><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;</div><div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;</div><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;##Modular build 2 and new interface for GPU 22/07/16## </div><div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div><div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;After discussing with my mentor, I did some changes to the code. </div><div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;</div><div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;The first new feature is that svmlight is optional, even if it comes as subdependency with the library for free. I added an **WITH_SVMLIGHT** option in the CMake to make it optional. Automatically all the dependand source files will be excluded (they should be the one using hog, the miscdetector and the depending examples).</div><div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;</div><div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;The second change is that I created a separate option Cmake file to set and create all options and I added a new option to show or remove compilation warnings.</div><div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;</div><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;The third change is a major change composed by two parts. The first one involves changing the interface of the **ODCascadeDetector** to have a simple interface for the users. I changed it by creating an interface called **ODCascadeDetector** which derives from **ODDetector2D** so that we can use it in all the containers. This class contains a shared pointer of a common interface, called **ODCascadeDetectorInterface**. Both the GPU and the CPU version of the **ODCascadeDetector** are called the same, **ODCascadeDetectorImpl**, but are in different namespaces and modules. This way I maintained the code separated and easy to maintain. In the **ODCascadeDetector** class, the constructor checks the first parameter and builds accordingly the correct object. Also there is a **Pragma** to check that the lirbary was compiled with GPU support.</div><div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;</div><div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;@code</div><div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;</div><div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;    ODCascadeDetector::ODCascadeDetector(bool gpu, const std::string &amp; trainer, const std::string &amp; trained_data_location, double scale_factor, int min_neighbors, int flags, </div><div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                                         const cv::Size &amp; min_size, const cv::Size &amp; max_size)</div><div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;    {</div><div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;      if(gpu){</div><div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;        std::cout &lt;&lt; &quot;creating gpu cascade detector&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;#if WITH_GPU</div><div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;  #ifdef WITH_BOOST_SHARED_PTR</div><div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;      cascade_detector_ = shared_ptr&lt;od::gpu::g2d::ODCascadeDetectorImpl&gt;(new od::gpu::g2d::ODCascadeDetectorImpl(trainer, trained_data_location, scale_factor, min_neighbors, flags, min_size, max_size));</div><div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;  #else</div><div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;      cascade_detector_ = make_shared&lt;od::gpu::g2d::ODCascadeDetectorImpl&gt;(trainer, trained_data_location, scale_factor, min_neighbors, flags, min_size, max_size);</div><div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;  #endif</div><div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;#else</div><div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;        std::cout &lt;&lt; &quot;Error !! GPU CascadeDetector has not been compiled. Recompile with WITH_GPU.&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;        exit(-1);</div><div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;#endif</div><div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;      }</div><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;      else {</div><div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;        std::cout &lt;&lt; &quot;creating cpu cascade detector&quot; &lt;&lt; std::endl;</div><div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;#ifdef WITH_BOOST_SHARED_PTR</div><div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;       cascade_detector_ = shared_ptr&lt;ODCascadeDetectorImpl&gt;(new ODCascadeDetectorImpl(trainer, trained_data_location, scale_factor, min_neighbors, flags, min_size, max_size));</div><div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;#else</div><div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;       cascade_detector_ = make_shared&lt;ODCascadeDetectorImpl&gt;(trainer, trained_data_location, scale_factor, min_neighbors, flags, min_size, max_size);</div><div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;#endif    </div><div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;      }</div><div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;    }</div><div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;</div><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;@endcode</div><div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;</div><div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;The second main change was to create the same interface for the **ODFeatureDetector2D** which could create gpu detectors or cpu ones. I did the same interface as before creating **ODFeatureDetector**, **ODFeatureDetector2D**, **ODFeatureDetectorInterface**. The constructor switches the passed parameter and based on the type allocates the correct feature detector, cpu or gpu. Also the gpu part is in the gpu module to maintain the advantages described before. </div><div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;The only small drawback of this structure is that the common module and the gpu_common module have a circular dependency on the include files, so we have to set the **include_directories** statment outside of the two modules. I do this in the **ODDependency.cmake** file.</div><div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div><div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;Obviously I had to change all the examples to adapt to this new structure, but that was not so hard, while the new interface was quite tricky to be created in a clean way.</div><div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;</div><div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;##Naming convention and build example 29/07/16## </div><div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;</div><div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;I changed the nameing convention in the library to adapt it to a more C++ style. Before all file names started with **OD**, along with all classes and types. This is useful in C code since you are laking namespaces, but in C++ it makes no sense. I changed everything to the new style and fixed some compilation errors which arose.</div><div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;</div><div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;I also changed the **WITH_BOOST_SHARED_PTR** to **WITH_STD_SHARED_PTR** since when you include the file in your own project the default will be boost.</div><div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;</div><div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;I created an example in apps/buildExample which shows how to create your own project using the opendetection lirbary.</div><div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;@code</div><div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div><div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;# Example on how to build a project using the OpenDetection Library</div><div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;</div><div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;cmake_minimum_required(VERSION 2.8)</div><div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;project(viewer)</div><div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;</div><div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;find_package(OD REQUIRED)</div><div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;find_package(PCL REQUIRED)</div><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;find_package(OpenCV REQUIRED)</div><div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div><div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;include_directories(${OD_INCLUDE_DIRS})</div><div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;include_directories(${PCL_INCLUDE_DIRS})</div><div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;include_directories(${OpenCV_INCLUDE_DIRS})</div><div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;</div><div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;link_directories(${OD_LIBRARY_PATH})</div><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;</div><div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;add_executable(viewer VisualizationTest.cpp)</div><div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;target_link_libraries(viewer ${OD_LIBRARIES} ${OpenCV_LIBS} ${PCL_LIBRARIES})</div><div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;</div><div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;@endcode</div><div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;</div><div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;This shows that you can use the provided config file, which is created during instllation time, to find and include the lirbary.</div><div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;I am finishing now the Doxygen documentation which is missing in some parts of the lbirary and then i will finish to do also some template percompilation which I saw was missing.</div><div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;After that there is the need to integrate the other google summer of code Project.</div><div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div><div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;</div><div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;##Integrating the caffe gsoc project 02/08/16## </div><div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div><div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;I integrated the work from Abhishek, who did the other gsoc project in opendetection. I had to adapt the fiel structure and naming convention to the new struture and change some code to use shared pointers; there is still some work to do to adapt and clean the code which has many flaws, but thats something which should be done as part of the other gsoc project. Anyway I added two new options in the cmake: **WITH_CAFFE** and **WITH_GTKMM**; the first one enables to build the OD library with Caffe support, while the second one adds to caffe also the visualization part. If the flag **WITH_GPU** is added then the Caffe gpu part will be used.</div><div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;I also restructured a bit the cmake structure adding some more searated cmake files and fixed the naming on the cmake files as for the other files.</div><div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;THe only thing missing now is a bit of documentation and then everything should be done :)</div><div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;</div><div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;##Integrating the caffe gsoc project 2 20/08/16## </div><div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div><div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;I finished integrating the other gsoc project except the examples which are havy in content, as they contain a lot of images etc which should be outside of the git repository.</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.6-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>gsoc2016_blog_giacomo.md</b></li>
    <li class="footer">Send your queries <a href="mailto:kripasindhu.sarkar@dfki.de?Subject=OpenDetection" target="_top">here</a>.</li>
  </ul>
</div>
</body>
</html>
